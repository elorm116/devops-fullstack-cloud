name: Deploy to Server (Docker Compose)

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: ["main"]

  # Allow manual deploys too
  workflow_dispatch:
    inputs:
      sha:
        description: "Commit SHA to deploy (optional; defaults to latest main workflow_run SHA)"
        required: false
        type: string

concurrency:
  group: deploy-server
  cancel-in-progress: true

permissions:
  contents: read
  packages: read

env:
  SERVER_HOST: nam.taild248f7.ts.net
  SERVER_USER: nam
  SERVER_DIR: ~/dockerize
  FRONTEND_PORT: "3001"

jobs:
  deploy:
    # Only auto-deploy if CI workflow succeeded
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Validate Secrets
        shell: bash
        run: |
          if [ -z "${{ secrets.TS_OAUTH_CLIENT_ID }}" ] || [ -z "${{ secrets.TS_OAUTH_SECRET }}" ]; then
            echo "::error::Tailscale OAuth secrets are missing!"
            exit 1
          fi

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Determine Metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          
          # 1. Resolve the correct SHA
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            FULL_SHA="${{ github.event.workflow_run.head_sha }}"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.sha }}" ]; then
            FULL_SHA="${{ inputs.sha }}"
          else
            FULL_SHA="${{ github.sha }}"
          fi
          
          # 2. Normalize repo name (Must be lowercase for GHCR)
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          
          echo "full=$FULL_SHA" >> "$GITHUB_OUTPUT"
          echo "short=${FULL_SHA:0:7}" >> "$GITHUB_OUTPUT"
          echo "repo_lower=$REPO_LOWER" >> "$GITHUB_OUTPUT"

      - name: Deploy via SSH
        env:
          SERVER_SSH_KEY: ${{ secrets.SERVER_SSH_KEY }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          # Setup SSH
          install -m 700 -d ~/.ssh
          printf '%s\n' "$SERVER_SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Construct Image Paths
          REPO_LOWER="${{ steps.meta.outputs.repo_lower }}"
          SHORT_SHA="${{ steps.meta.outputs.short }}"
          API_IMAGE="ghcr.io/${REPO_LOWER}/api:sha-${SHORT_SHA}"
          FRONTEND_IMAGE="ghcr.io/${REPO_LOWER}/frontend:sha-${SHORT_SHA}"

          # Encode token for safe transmission
          GHCR_TOKEN_B64="$(printf %s "$GHCR_TOKEN" | base64 -w0)"

          ssh -i ~/.ssh/id_ed25519 \
            -o ConnectTimeout=30 \
            "$SERVER_USER@$SERVER_HOST" \
            "GHCR_TOKEN_B64='$GHCR_TOKEN_B64' API_IMAGE='$API_IMAGE' FRONTEND_IMAGE='$FRONTEND_IMAGE' SERVER_DIR='$SERVER_DIR' FRONTEND_PORT='$FRONTEND_PORT' bash -s" << 'EOSSH'
          set -euo pipefail

          # Decode token and login
          GHCR_TOKEN="$(printf %s "$GHCR_TOKEN_B64" | base64 -d)"
          
          # Use explicit username for reliable GHCR authentication
          echo "$GHCR_TOKEN" | docker login ghcr.io -u elorm116 --password-stdin

          # Ensure Directory Exists
          SERVER_DIR="${SERVER_DIR/#\~/$HOME}"
          mkdir -p "$SERVER_DIR"
          cd "$SERVER_DIR"

          # Pull and Pin to Digests (Immutability)
          echo "Pulling images: $API_IMAGE and $FRONTEND_IMAGE"
          docker pull "$API_IMAGE"
          docker pull "$FRONTEND_IMAGE"
          
          API_DIGEST="$(docker image inspect "$API_IMAGE" --format '{{index .RepoDigests 0}}')"
          FRONTEND_DIGEST="$(docker image inspect "$FRONTEND_IMAGE" --format '{{index .RepoDigests 0}}')"

          # Generate Compose File
          cat > docker-compose.prod.yaml <<EOF
          services:
            app:
              container_name: myjs-app
              image: ${API_DIGEST}
              restart: unless-stopped
              environment:
                - NODE_ENV=production
                - PORT=4000
              expose:
                - "4000"
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- http://localhost:4000/health >/dev/null || exit 1"]
                interval: 10s
                timeout: 3s
                retries: 5
                start_period: 10s

            myblog:
              container_name: myreact-app
              image: ${FRONTEND_DIGEST}
              restart: unless-stopped
              ports:
                - "${FRONTEND_PORT}:80"
              depends_on:
                app:
                  condition: service_healthy
          EOF

          # Deploy
          docker compose -f docker-compose.prod.yaml up -d --remove-orphans
          docker compose -f docker-compose.prod.yaml ps
          
          # Explicitly end the SSH block
          exit
          
          # The line below MUST NOT have leading spaces
          EOSSH

      - name: Summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "* **Host:** ${SERVER_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "* **SHA:** ${{ steps.meta.outputs.short }}" >> $GITHUB_STEP_SUMMARY
          echo "* **URL:** http://${SERVER_HOST}:${FRONTEND_PORT}" >> $GITHUB_STEP_SUMMARY