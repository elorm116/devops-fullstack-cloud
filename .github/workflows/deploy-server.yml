name: Deploy to Server (Docker Hub)

on:
  workflow_dispatch:
    inputs:
      sha:
        description: "Commit SHA to deploy"
        required: false

env:
  DOCKERHUB_USER: elorm116
  SERVER_HOST: nam.taild248f7.ts.net
  SERVER_USER: nam
  SERVER_DIR: ~/dockerize
  FRONTEND_PORT: "3001"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Determine Metadata
        id: meta
        run: |
          FULL_SHA="${{ github.event.inputs.sha || github.sha }}"
          SHORT_SHA="${FULL_SHA:0:7}"
          echo "short=$SHORT_SHA" >> "$GITHUB_OUTPUT"
          echo "api_image=${{ env.DOCKERHUB_USER }}/mjs-app:sha-$SHORT_SHA" >> "$GITHUB_OUTPUT"
          echo "frontend_image=${{ env.DOCKERHUB_USER }}/myreact-app:sha-$SHORT_SHA" >> "$GITHUB_OUTPUT"

      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push API (mjs-app)
        uses: docker/build-push-action@v6
        with:
          context: ./api
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.api_image }},${{ env.DOCKERHUB_USER }}/mjs-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Push Frontend (myreact-app)
        uses: docker/build-push-action@v6
        with:
          context: ./myblog
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.frontend_image }},${{ env.DOCKERHUB_USER }}/myreact-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Deploy via SSH
        env:
          SERVER_SSH_KEY: ${{ secrets.SERVER_SSH_KEY }}
          SERVER_FINGERPRINT: ${{ secrets.SERVER_FINGERPRINT }}
          API_IMAGE: ${{ steps.meta.outputs.api_image }}
          FRONTEND_IMAGE: ${{ steps.meta.outputs.frontend_image }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          install -m 700 -d ~/.ssh
          printf '%s\n' "$SERVER_SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

          # Use stored fingerprint instead of blind ssh-keyscan
          printf '%s\n' "$SERVER_FINGERPRINT" >> ~/.ssh/known_hosts

          ssh -i ~/.ssh/id_ed25519 "$SERVER_USER@$SERVER_HOST" \
            API_IMAGE="$API_IMAGE" \
            FRONTEND_IMAGE="$FRONTEND_IMAGE" \
            SERVER_DIR="$SERVER_DIR" \
            FRONTEND_PORT="$FRONTEND_PORT" \
            DOCKERHUB_USER="$DOCKERHUB_USER" \
            DOCKERHUB_TOKEN="$DOCKERHUB_TOKEN" \
            bash -s <<'EOSSH'
          set -euo pipefail

          # Login to Docker Hub on server to avoid anonymous rate limits
          echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USER" --password-stdin

          mkdir -p "$SERVER_DIR" && cd "$SERVER_DIR"

          # Pull new images
          docker pull "$API_IMAGE"
          docker pull "$FRONTEND_IMAGE"

          # Pin to digests for immutability
          API_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$API_IMAGE")
          FRONTEND_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$FRONTEND_IMAGE")

          # Backup current compose file for rollback
          [ -f docker-compose.prod.yaml ] && cp docker-compose.prod.yaml docker-compose.prod.yaml.bak

          cat > docker-compose.prod.yaml << EOF
          services:
            app:
              image: ${API_DIGEST}
              container_name: myjs-app
              restart: unless-stopped
              environment:
                - NODE_ENV=production
                - PORT=4000
              expose:
                - "4000"
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- http://localhost:4000/health >/dev/null || exit 1"]
                interval: 10s
                timeout: 3s
                retries: 3
                start_period: 15s

            myblog:
              image: ${FRONTEND_DIGEST}
              container_name: myreact-app
              restart: unless-stopped
              ports:
                - "${FRONTEND_PORT}:80"
              depends_on:
                app:
                  condition: service_healthy
          EOF

          # Deploy, and rollback if it fails
          if ! docker compose -f docker-compose.prod.yaml up -d --remove-orphans; then
            echo "Deploy failed â€” rolling back..."
            [ -f docker-compose.prod.yaml.bak ] && mv docker-compose.prod.yaml.bak docker-compose.prod.yaml
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
            exit 1
          fi

          # Cleanup old dangling images to free disk space
          docker image prune -f
          EOSSH