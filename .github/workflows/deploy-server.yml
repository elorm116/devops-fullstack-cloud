name: Deploy to Server (Docker Hub)

on:
  workflow_dispatch:
    inputs:
      sha:
        description: "Commit SHA to deploy (default: latest)"
        required: false
      version:
        description: "Version tag (e.g. v1.2.0) — optional, adds semver tag to images"
        required: false

env:
  DOCKERHUB_USER: elorm116
  SERVER_HOST: nam.taild248f7.ts.net
  SERVER_USER: nam
  SERVER_DIR: ~/dockerize
  FRONTEND_PORT: "3001"
  GRAFANA_PORT: "3002"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Determine Metadata
        id: meta
        run: |
          FULL_SHA="${{ github.event.inputs.sha || github.sha }}"
          SHORT_SHA="${FULL_SHA:0:7}"
          VERSION="${{ github.event.inputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          API_TAGS="${{ env.DOCKERHUB_USER }}/myjs-app:sha-${SHORT_SHA},${{ env.DOCKERHUB_USER }}/myjs-app:latest"
          FE_TAGS="${{ env.DOCKERHUB_USER }}/myreact-app:sha-${SHORT_SHA},${{ env.DOCKERHUB_USER }}/myreact-app:latest"

          if [[ -n "$VERSION" ]]; then
            SEMVER="${VERSION#v}"
            MINOR="${SEMVER%.*}"
            API_TAGS="${API_TAGS},${{ env.DOCKERHUB_USER }}/myjs-app:${SEMVER},${{ env.DOCKERHUB_USER }}/myjs-app:${MINOR}"
            FE_TAGS="${FE_TAGS},${{ env.DOCKERHUB_USER }}/myreact-app:${SEMVER},${{ env.DOCKERHUB_USER }}/myreact-app:${MINOR}"
          fi

          echo "short=$SHORT_SHA"                                                       >> "$GITHUB_OUTPUT"
          echo "full_sha=$FULL_SHA"                                                     >> "$GITHUB_OUTPUT"
          echo "version=${VERSION:-sha-$SHORT_SHA}"                                     >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE"                                                 >> "$GITHUB_OUTPUT"
          echo "api_image=${{ env.DOCKERHUB_USER }}/myjs-app:sha-$SHORT_SHA"           >> "$GITHUB_OUTPUT"
          echo "frontend_image=${{ env.DOCKERHUB_USER }}/myreact-app:sha-$SHORT_SHA"   >> "$GITHUB_OUTPUT"
          echo "api_tags=$API_TAGS"                                                     >> "$GITHUB_OUTPUT"
          echo "fe_tags=$FE_TAGS"                                                       >> "$GITHUB_OUTPUT"

      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push API (myjs-app)
        uses: docker/build-push-action@v6
        with:
          context: ./api
          target: production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.api_tags }}
          build-args: |
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            VCS_REF=${{ steps.meta.outputs.full_sha }}
            VERSION=${{ steps.meta.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Push Frontend (myreact-app)
        uses: docker/build-push-action@v6
        with:
          context: ./myblog
          target: production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.fe_tags }}
          build-args: |
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            VCS_REF=${{ steps.meta.outputs.full_sha }}
            VERSION=${{ steps.meta.outputs.version }}
            REACT_APP_GOOGLE_CLIENT_ID=${{ secrets.REACT_APP_GOOGLE_CLIENT_ID }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Setup SSH
        env:
          SERVER_SSH_KEY: ${{ secrets.SERVER_SSH_KEY }}
          SERVER_FINGERPRINT: ${{ secrets.SERVER_FINGERPRINT }}
        run: |
          install -m 700 -d ~/.ssh
          printf '%s\n' "$SERVER_SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          printf '%s\n' "$SERVER_FINGERPRINT" >> ~/.ssh/known_hosts

      - name: Copy configs to server
        run: |
          ssh -i ~/.ssh/id_ed25519 "$SERVER_USER@$SERVER_HOST" "mkdir -p $SERVER_DIR"
          scp -r -i ~/.ssh/id_ed25519 ./monitoring "$SERVER_USER@$SERVER_HOST:$SERVER_DIR/"
          scp -r -i ~/.ssh/id_ed25519 ./scripts "$SERVER_USER@$SERVER_HOST:$SERVER_DIR/"

      - name: Deploy via SSH
        env:
          API_IMAGE: ${{ steps.meta.outputs.api_image }}
          FRONTEND_IMAGE: ${{ steps.meta.outputs.frontend_image }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          GRAFANA_ADMIN_USER: ${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}
          VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}
          MONGO_ROOT_USER: ${{ secrets.MONGO_ROOT_USER }}
          MONGO_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
          MONGO_APP_PASSWORD: ${{ secrets.MONGO_APP_PASSWORD }}
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
        run: |
          ssh -i ~/.ssh/id_ed25519 "$SERVER_USER@$SERVER_HOST" \
            API_IMAGE="$API_IMAGE" \
            FRONTEND_IMAGE="$FRONTEND_IMAGE" \
            SERVER_DIR="$SERVER_DIR" \
            FRONTEND_PORT="$FRONTEND_PORT" \
            GRAFANA_PORT="$GRAFANA_PORT" \
            DOCKERHUB_USER="$DOCKERHUB_USER" \
            DOCKERHUB_TOKEN="$DOCKERHUB_TOKEN" \
            JWT_SECRET="$JWT_SECRET" \
            GRAFANA_ADMIN_USER="$GRAFANA_ADMIN_USER" \
            GRAFANA_ADMIN_PASSWORD="$GRAFANA_ADMIN_PASSWORD" \
            VAULT_ROLE_ID="$VAULT_ROLE_ID" \
            VAULT_SECRET_ID="$VAULT_SECRET_ID" \
            MONGO_ROOT_USER="$MONGO_ROOT_USER" \
            MONGO_ROOT_PASSWORD="$MONGO_ROOT_PASSWORD" \
            MONGO_APP_PASSWORD="$MONGO_APP_PASSWORD" \
            CORS_ORIGIN="$CORS_ORIGIN" \
            GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
            bash -s << 'EOSSH'
          set -euo pipefail

          # Fail loudly if critical secrets are missing
          : "${JWT_SECRET:?JWT_SECRET is not set}"
          : "${GRAFANA_ADMIN_USER:?GRAFANA_ADMIN_USER is not set}"
          : "${GRAFANA_ADMIN_PASSWORD:?GRAFANA_ADMIN_PASSWORD is not set}"
          : "${MONGO_ROOT_USER:?MONGO_ROOT_USER is not set}"
          : "${MONGO_ROOT_PASSWORD:?MONGO_ROOT_PASSWORD is not set}"
          : "${MONGO_APP_PASSWORD:?MONGO_APP_PASSWORD is not set}"
          : "${GOOGLE_CLIENT_ID:?GOOGLE_CLIENT_ID is not set}"
          # Vault creds are optional on first deploy
          if [ -z "${VAULT_ROLE_ID:-}" ] || [ "$VAULT_ROLE_ID" = "placeholder" ]; then
            echo "⚠️  VAULT_ROLE_ID not set — Vault features disabled."
          fi

          echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USER" --password-stdin

          mkdir -p "$SERVER_DIR" && cd "$SERVER_DIR"

          docker pull "$API_IMAGE"
          docker pull "$FRONTEND_IMAGE"

          API_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$API_IMAGE")
          FRONTEND_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$FRONTEND_IMAGE")

          [ -f docker-compose.prod.yaml ] && cp docker-compose.prod.yaml docker-compose.prod.yaml.bak

          cat > docker-compose.prod.yaml << EOF
          services:
            db:
              image: mongo:7
              container_name: mongodb
              restart: unless-stopped
              environment:
                - MONGO_INITDB_ROOT_USERNAME=${MONGO_ROOT_USER}
                - MONGO_INITDB_ROOT_PASSWORD=${MONGO_ROOT_PASSWORD}
                - MONGO_APP_PASSWORD=${MONGO_APP_PASSWORD}
              volumes:
                - mongo-data:/data/db
                - ./scripts/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
              healthcheck:
                test: ["CMD", "mongosh", "--quiet", "--eval", "db.adminCommand('ping')"]
                interval: 10s
                timeout: 5s
                retries: 5
                start_period: 20s
              networks:
                - blog-network

            vault:
              image: hashicorp/vault:1.16
              container_name: vault
              restart: unless-stopped
              cap_add:
                - IPC_LOCK
              environment:
                VAULT_LOCAL_CONFIG: |
                  {
                    "storage": { "file": { "path": "/vault/data" } },
                    "listener": [{ "tcp": { "address": "0.0.0.0:8200", "tls_disable": true } }],
                    "default_lease_ttl": "1h",
                    "max_lease_ttl": "4h",
                    "ui": true
                  }
              command: server
              volumes:
                - vault-data:/vault/data
                - vault-audit:/vault/audit
              ports:
                - "8200:8200"
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:8200/v1/sys/init || exit 1"]
                interval: 10s
                timeout: 3s
                retries: 5
                start_period: 10s
              networks:
                - blog-network

            app:
              image: ${API_DIGEST}
              container_name: api_container
              restart: unless-stopped
              environment:
                - NODE_ENV=production
                - PORT=4000
                - MONGO_URI=mongodb://blogapi:${MONGO_APP_PASSWORD}@db:27017/blog?authSource=blog
                - JWT_SECRET=${JWT_SECRET}
                - CORS_ORIGIN=${CORS_ORIGIN}
                - VAULT_ADDR=http://vault:8200
                - VAULT_ROLE_ID=${VAULT_ROLE_ID}
                - VAULT_SECRET_ID=${VAULT_SECRET_ID}
                - GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
              expose:
                - "4000"
              depends_on:
                - db
                - vault
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:4000/health >/dev/null || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 5
                start_period: 20s
              networks:
                - blog-network

            myblog:
              image: ${FRONTEND_DIGEST}
              container_name: myblog_container
              restart: unless-stopped
              ports:
                - "${FRONTEND_PORT}:80"
              depends_on:
                - app
              networks:
                - blog-network

            prometheus:
              image: prom/prometheus:v2.51.0
              container_name: prometheus
              restart: unless-stopped
              volumes:
                - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
                - prometheus-data:/prometheus
              command:
                - '--config.file=/etc/prometheus/prometheus.yml'
                - '--storage.tsdb.path=/prometheus'
                - '--storage.tsdb.retention.time=15d'
              depends_on:
                - app
              networks:
                - blog-network

            grafana:
              image: grafana/grafana:10.4.1
              container_name: grafana
              restart: unless-stopped
              ports:
                - "${GRAFANA_PORT}:3000"
              volumes:
                - ./monitoring/grafana-provisioning/datasources:/etc/grafana/provisioning/datasources:ro
                - ./monitoring/grafana-provisioning/dashboards:/etc/grafana/provisioning/dashboards:ro
                - grafana-data:/var/lib/grafana
              environment:
                - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER}
                - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
                - GF_USERS_ALLOW_SIGN_UP=false
              depends_on:
                - prometheus
              networks:
                - blog-network

          volumes:
            mongo-data:
            vault-data:
            vault-audit:
            prometheus-data:
            grafana-data:

          networks:
            blog-network:
              driver: bridge
          EOF

          # ── Step 1: Bring up MongoDB and wait for FULL initialization ──
          docker compose -f docker-compose.prod.yaml up -d db

          # Wait for MongoDB to finish init (creates root user, runs init scripts, restarts with auth).
          # A simple ping succeeds too early (before the auth restart). Instead, wait for
          # authenticated ping to work, which proves init is fully complete.
          echo "⏳ Waiting for MongoDB to fully initialize..."
          RETRIES=0
          until docker exec mongodb mongosh \
            -u "${MONGO_ROOT_USER}" -p "${MONGO_ROOT_PASSWORD}" \
            --authenticationDatabase admin --quiet \
            --eval "db.adminCommand('ping')" >/dev/null 2>&1; do
            RETRIES=$((RETRIES + 1))
            if [ "$RETRIES" -ge 30 ]; then
              echo "❌ MongoDB did not become ready in time"
              docker logs mongodb 2>&1 | tail -40
              exit 1
            fi
            sleep 3
          done
          echo "✅ MongoDB is ready (authenticated)"

          # Ensure the blogapi app user exists (idempotent — safe to run every deploy)
          docker exec mongodb mongosh \
            -u "${MONGO_ROOT_USER}" -p "${MONGO_ROOT_PASSWORD}" \
            --authenticationDatabase admin --quiet --eval "
              const blog = db.getSiblingDB('blog');
              const existing = blog.getUsers().users.find(u => u.user === 'blogapi');
              if (!existing) {
                blog.createUser({ user: 'blogapi', pwd: '${MONGO_APP_PASSWORD}', roles: [{ role: 'readWrite', db: 'blog' }] });
                print('✅ Created blogapi user');
              } else {
                print('ℹ️  blogapi user already exists');
              }
            "

          # ── Step 2: Bring up all remaining services ──
          if ! docker compose -f docker-compose.prod.yaml up -d --remove-orphans; then
            echo "Deploy failed — capturing diagnostics..."
            echo "--- api_container logs ---"
            docker logs api_container 2>&1 | tail -50 || true
            echo "--- mongodb logs ---"
            docker logs mongodb 2>&1 | tail -20 || true
            echo "--- vault logs ---"
            docker logs vault 2>&1 | tail -20 || true
            echo "--- Rolling back ---"
            [ -f docker-compose.prod.yaml.bak ] && mv docker-compose.prod.yaml.bak docker-compose.prod.yaml
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
            exit 1
          fi

          VAULT_STATUS=$(docker exec vault wget -qO- http://127.0.0.1:8200/v1/sys/seal-status 2>/dev/null || echo '{}')
          INITIALIZED=$(echo "$VAULT_STATUS" | python3 -c "import sys,json; print(json.load(sys.stdin).get('initialized', False))" 2>/dev/null || echo "False")
          SEALED=$(echo "$VAULT_STATUS" | python3 -c "import sys,json; print(json.load(sys.stdin).get('sealed', True))" 2>/dev/null || echo "True")

          echo ""
          if [ "$INITIALIZED" = "False" ]; then
            echo "⚠️  Vault is NOT initialized."
            echo "   SSH in and run: cd $SERVER_DIR && bash scripts/vault-init.sh"
          elif [ "$SEALED" = "True" ]; then
            echo "⚠️  Vault is sealed."
            echo "   SSH in and run: cd $SERVER_DIR && bash scripts/vault-unseal.sh"
          else
            echo "✅ Vault is initialized and unsealed."
          fi

          docker image prune -f
          EOSSH